import sys  
sys.path.append('/home/rhea_huang/anaconda3/lib/python3.10/site-packages')
import openql as ql
import os
import numpy as np
import math
import re
import qiskit
from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, Aer, execute
from qiskit.quantum_info import Operator

def convert_qasm(openql_qasm, nqubits):
    with open(openql_qasm, 'r') as f:
      openql_lines = f.readlines()

    gate_map = {
        'rx': 'rx',
        'ry': 'ry',
        'rz': 'rz',
        'x': 'x',
        'y': 'y',
        'z': 'z',
        'h': 'h',
        's': 's',
        'sdg': 'sdg',
        't': 't',
        'tdg': 'tdg',
        'cnot': 'cx'
    }

    qiskit_lines = []
    qiskit_lines.append('OPENQASM 2.0;\n')
    qiskit_lines.append('include "qelib1.inc";\n')
    qiskit_lines.append('qreg q[' + str(nqubits) + '];\n')
    # Define regular expression pattern to match
    pattern = re.compile(r'(\w+)\s+q\[([0-9]+)\],\s*(-?[0-9]+\.?[0-9]*)')
    for i in range(len(openql_lines)):
        if openql_lines[i].startswith('pragma') or openql_lines[i].startswith('.newKernel') or openql_lines[i].startswith('version 1.2') or openql_lines[i].startswith('# Generated by OpenQL') or openql_lines[i].isspace():
            continue
        line = pattern.sub(lambda m: '{}({}) q[{}]'.format(gate_map[m.group(1)], m.group(3), m.group(2)), openql_lines[i])
        line = line.replace("cnot", "cx")
        line = line.replace('\n', ';\n')
        line = line.replace('    ', '')
        
        qiskit_lines.append(line)

    return ''.join(qiskit_lines)


matrix_str = sys.argv[1:][0]
matrix_dim = int(sys.argv[1:][1])
nqubits = math.log2(matrix_dim)

# check the dimension, exit if not power of 2
if (not nqubits.is_integer()) :
    print("input matrix is not divisible into qubit subsystems")
    sys.exit(1)

nqubits = int(nqubits)

# Define a pattern to match each complex number
pattern = r"\(([+-]?\d+\.\d+)[eE]([+-]?\d+),([+-]?\d+\.\d+)[eE]([+-]?\d+)\)"
# Extract the real and imaginary parts 
matches = re.findall(pattern, matrix_str)
# convert to numpy array
arr = np.array([complex(float(m[0]+'e'+m[1]), float(m[2]+'e'+m[3])) for m in matches]).reshape(-matrix_dim, matrix_dim)
print("Matrix to be factorized:\n",arr)
op = Operator(arr)

qc = QuantumCircuit(nqubits)
qc.unitary(op, list(range(int(nqubits))), label="original gate")

print("\nOriginal circuit:")
print(qc.draw())
print("\n")


# ------------start decomposing------------------------

curdir = "Decomposition/"
ql.set_option('output_dir', os.path.join(curdir, 'output'))
ql.set_option('log_level', 'LOG_ERROR')

platf = ql.Platform('none')
program = ql.Program('example', platf, nqubits)
kernel = ql.Kernel('newKernel', platf, nqubits)

compiler = ql.Compiler('compiler1')
vector_matrix = [complex(x) for x in arr.flatten()]
u1 = ql.Unitary("testname",vector_matrix)
u1.decompose()
kernel.gate(u1, range(0, nqubits))
program.add_kernel(kernel)
program.compile()

qiskit_string = convert_qasm("Decomposition/output/example.qasm", nqubits)
# Load the QASM file
qasm_string = qiskit_string

# Create a quantum circuit from the QASM string
qc = QuantumCircuit.from_qasm_str(str(qasm_string))

# Simulate the circuit on the qasm_simulator backend
backend = Aer.get_backend('qasm_simulator')
job = execute(qc, backend)
result = job.result()
print("\nDiscretized circuit:")
print(qc.draw())

print("Error:", np.linalg.norm(Operator(qc).data - Operator(arr).data))

